# Kompletny Kurs: Budowa Przedstawiciela Handlowego z OpenAI Agents SDK

## Wprowadzenie

Witaj w kompleksowym kursie budowy systemu wieloagentowego z wykorzystaniem **OpenAI Agents SDK**! W tym artykule krok po kroku nauczysz siÄ™, jak stworzyÄ‡ inteligentnego przedstawiciela handlowego, ktÃ³ry potrafi generowaÄ‡ i wysyÅ‚aÄ‡ wiadomoÅ›ci e-mail w rÃ³Å¼nych stylach komunikacji.

### Czego siÄ™ nauczysz?

Po ukoÅ„czeniu tego kursu bÄ™dziesz potrafiÅ‚:

- âœ… TworzyÄ‡ i konfigurowaÄ‡ agentÃ³w AI z rÃ³Å¼nymi "osobowoÅ›ciami"
- âœ… UÅ¼ywaÄ‡ narzÄ™dzi (Tools) do integracji funkcji z agentami
- âœ… ImplementowaÄ‡ przekazywanie kontroli (Handoffs) miÄ™dzy agentami
- âœ… BudowaÄ‡ hierarchiczne systemy wieloagentowe
- âœ… WykorzystywaÄ‡ asynchroniczne programowanie w Pythonie do rÃ³wnolegÅ‚ego uruchamiania agentÃ³w
- âœ… IntegrowaÄ‡ zewnÄ™trzne API (SendGrid) z systemem agentowym

### Wymagania wstÄ™pne

- Podstawowa znajomoÅ›Ä‡ Pythona (funkcje, klasy, importy)
- Podstawowa znajomoÅ›Ä‡ programowania asynchronicznego (async/await) - wyjaÅ›nimy to w trakcie kursu
- Konto OpenAI z dostÄ™pem do API
- Konto SendGrid (darmowe) do wysyÅ‚ki e-maili

---

## CzÄ™Å›Ä‡ 1: Przygotowanie Å›rodowiska

### Krok 1.1: Instalacja zaleÅ¼noÅ›ci

Zacznijmy od przygotowania Å›rodowiska. UtwÃ³rz nowy katalog projektu i zainstaluj wymagane pakiety:

```bash
pip install openai-agents python-dotenv sendgrid
```

Lub uÅ¼yj pliku `requirements.txt`:

```bash
pip install -r requirements.txt
```

### Krok 1.2: Konfiguracja SendGrid

SendGrid to platforma do wysyÅ‚ki transakcyjnych wiadomoÅ›ci e-mail. BÄ™dziemy jej uÅ¼ywaÄ‡ jako narzÄ™dzia Å›wiata rzeczywistego, ktÃ³re nasi agenci bÄ™dÄ… mogli wykorzystywaÄ‡.

#### Krok 1.2.1: Utworzenie konta SendGrid

1. OdwiedÅº [https://sendgrid.com/](https://sendgrid.com/)
2. UtwÃ³rz darmowe konto
3. Po zalogowaniu przejdÅº do: **Settings** â†’ **API Keys** â†’ **Create API Key**
4. Skopiuj wygenerowany klucz API

#### Krok 1.2.2: Weryfikacja nadawcy

Aby SendGrid mÃ³gÅ‚ wysyÅ‚aÄ‡ e-maile w Twoim imieniu, musisz zweryfikowaÄ‡ adres nadawcy:

1. PrzejdÅº do: **Settings** â†’ **Sender Authentication** â†’ **Verify a Single Sender**
2. Podaj swÃ³j adres e-mail i zweryfikuj go

#### Krok 1.2.3: Konfiguracja zmiennych Å›rodowiskowych

UtwÃ³rz plik `.env` w katalogu gÅ‚Ã³wnym projektu:

```env
SENDGRID_API_KEY=twÃ³j_klucz_api_tutaj
FROM_EMAIL=twÃ³j_zweryfikowany_email@example.com
TO_EMAIL=adres_odbiorcy@example.com
OPENAI_API_KEY=twÃ³j_klucz_openai_tutaj
```

**âš ï¸ WaÅ¼ne:** Plik `.env` zawiera wraÅ¼liwe dane - nigdy nie commituj go do repozytorium Git!

### Krok 1.3: Test konfiguracji

StwÃ³rzmy prostÄ… funkcjÄ™ testowÄ…, aby sprawdziÄ‡, czy wszystko dziaÅ‚a:

```python
import os
import sendgrid
from dotenv import load_dotenv
from sendgrid.helpers.mail import Content, Email, Mail, To

load_dotenv()

def send_test_email():
    """WysyÅ‚a testowy e-mail, aby zweryfikowaÄ‡ konfiguracjÄ™ SendGrid"""
    sg = sendgrid.SendGridAPIClient(api_key=os.environ.get("SENDGRID_API_KEY"))
    from_email = Email(os.environ.get("FROM_EMAIL"))
    to_email = To(os.environ.get("TO_EMAIL"))
    content = Content("text/plain", "To jest waÅ¼ny testowy e-mail")
    mail = Mail(from_email, to_email, "Test e-mail", content).get()
    response = sg.client.mail.send.post(request_body=mail)
    print(f"Status odpowiedzi: {response.status_code}")
    if response.status_code == 202:
        print("âœ… E-mail wysÅ‚any pomyÅ›lnie!")

send_test_email()
```

JeÅ›li otrzymasz status `202`, oznacza to, Å¼e konfiguracja dziaÅ‚a poprawnie! SprawdÅº swojÄ… skrzynkÄ™ odbiorczÄ….

---

## CzÄ™Å›Ä‡ 2: Podstawy OpenAI Agents SDK

### Czym jest OpenAI Agents SDK?

**OpenAI Agents SDK** to framework, ktÃ³ry upraszcza tworzenie systemÃ³w wieloagentowych. Zamiast rÄ™cznie pisaÄ‡ JSON Schema i obsÅ‚ugiwaÄ‡ wywoÅ‚ania funkcji, framework automatycznie:

- Generuje schematy JSON z metadanych Pythona
- ZarzÄ…dza przepÅ‚ywem pracy miÄ™dzy agentami
- ObsÅ‚uguje asynchroniczne wywoÅ‚ania
- UmoÅ¼liwia Å›ledzenie (tracing) dziaÅ‚aÅ„ agentÃ³w

### Kluczowe komponenty

#### 1. Agent

`Agent` to podstawowa jednostka w systemie. Reprezentuje inteligentnego asystenta z okreÅ›lonymi instrukcjami i moÅ¼liwoÅ›ciami.

```python
from agents import Agent

agent = Agent(
    name="MÃ³j Agent",
    instructions="JesteÅ› pomocnym asystentem...",
    model="gpt-4o-mini"
)
```

**Parametry:**
- `name`: Nazwa agenta (uÅ¼ywana w Å›ledzeniu)
- `instructions`: Monit systemowy okreÅ›lajÄ…cy zachowanie agenta
- `model`: Model LLM do uÅ¼ycia (np. "gpt-4o-mini", "gpt-4o")

#### 2. Runner

`Runner` zarzÄ…dza wykonywaniem agentÃ³w. UmoÅ¼liwia uruchamianie agentÃ³w synchronicznie lub asynchronicznie.

```python
from agents import Runner

# Synchroniczne uruchomienie
result = await Runner.run(agent, "Twoja wiadomoÅ›Ä‡")

# Strumieniowe uruchomienie (dla UI)
result = Runner.run_streamed(agent, input="Twoja wiadomoÅ›Ä‡")
```

#### 3. Trace

`trace` to kontekstowy menedÅ¼er do Å›ledzenia dziaÅ‚aÅ„ agentÃ³w. Wszystkie operacje wewnÄ…trz bloku `with trace(...)` sÄ… automatycznie logowane na platformie OpenAI.

```python
from agents import trace

with trace("Nazwa operacji"):
    result = await Runner.run(agent, "WiadomoÅ›Ä‡")
```

---

## CzÄ™Å›Ä‡ 3: Tworzenie pierwszych agentÃ³w

### Krok 3.1: Definicja agentÃ³w sprzedaÅ¼y

Zacznijmy od stworzenia trzech agentÃ³w sprzedaÅ¼y, z ktÃ³rych kaÅ¼dy ma innÄ… "osobowoÅ›Ä‡":

```python
from agents import Agent

# Instrukcje dla agenta profesjonalnego
instructions_professional = (
    "JesteÅ› agentem sprzedaÅ¼y pracujÄ…cym dla ComplAI, "
    "firmy oferujÄ…cej narzÄ™dzie SaaS do zapewnienia zgodnoÅ›ci SOC2 i przygotowania do audytÃ³w, "
    "napÄ™dzane przez AI. Piszesz profesjonalne, powaÅ¼ne e-maile sprzedaÅ¼owe."
)

# Instrukcje dla agenta angaÅ¼ujÄ…cego
instructions_engaging = (
    "JesteÅ› dowcipnym, angaÅ¼ujÄ…cym agentem sprzedaÅ¼y pracujÄ…cym dla ComplAI, "
    "firmy oferujÄ…cej narzÄ™dzie SaaS do zapewnienia zgodnoÅ›ci SOC2 i przygotowania do audytÃ³w, "
    "napÄ™dzane przez AI. Piszesz dowcipne, angaÅ¼ujÄ…ce e-maile sprzedaÅ¼owe, ktÃ³re prawdopodobnie otrzymajÄ… odpowiedÅº."
)

# Instrukcje dla agenta zwiÄ™zÅ‚ego
instructions_concise = (
    "JesteÅ› zajÄ™tym agentem sprzedaÅ¼y pracujÄ…cym dla ComplAI, "
    "firmy oferujÄ…cej narzÄ™dzie SaaS do zapewnienia zgodnoÅ›ci SOC2 i przygotowania do audytÃ³w, "
    "napÄ™dzane przez AI. Piszesz zwiÄ™zÅ‚e, rzeczowe e-maile sprzedaÅ¼owe."
)

# Tworzenie agentÃ³w
sales_agent1 = Agent(
    name="Profesjonalny Agent SprzedaÅ¼y",
    instructions=instructions_professional,
    model="gpt-4o-mini"
)

sales_agent2 = Agent(
    name="AngaÅ¼ujÄ…cy Agent SprzedaÅ¼y",
    instructions=instructions_engaging,
    model="gpt-4o-mini"
)

sales_agent3 = Agent(
    name="ZajÄ™ty Agent SprzedaÅ¼y",
    instructions=instructions_concise,
    model="gpt-4o-mini"
)
```

### Dlaczego instrukcje sÄ… waÅ¼ne?

**Instrukcje (monity systemowe)** to kluczowy element definiujÄ…cy zachowanie agenta. OkreÅ›lajÄ… one:

- **Kontekst**: W jakiej sytuacji agent dziaÅ‚a
- **Ton**: Jak agent komunikuje siÄ™
- **Zachowanie**: Co agent powinien robiÄ‡

RÃ³Å¼ne instrukcje prowadzÄ… do rÃ³Å¼nych stylÃ³w odpowiedzi, co jest kluczowe w systemach wieloagentowych, gdzie chcemy mieÄ‡ rÃ³Å¼norodnoÅ›Ä‡.

### Krok 3.2: Testowanie pojedynczego agenta

Przetestujmy jednego z agentÃ³w:

```python
from agents import Runner

message = "Napisz zimny e-mail sprzedaÅ¼owy"
result = await Runner.run(sales_agent1, message)
print(result.final_output)
```

### Krok 3.3: Strumieniowanie odpowiedzi (Streaming)

Dla lepszego doÅ›wiadczenia uÅ¼ytkownika moÅ¼emy wyÅ›wietlaÄ‡ odpowiedÅº fragment po fragmencie:

```python
from agents import Runner
from openai.types.responses import ResponseTextDeltaEvent

result = Runner.run_streamed(sales_agent1, input="Napisz zimny e-mail sprzedaÅ¼owy")

async for event in result.stream_events():
    if event.type == "raw_response_event" and isinstance(event.data, ResponseTextDeltaEvent):
        print(event.data.delta, end="", flush=True)
```

**RÃ³Å¼nica miÄ™dzy `run` a `run_streamed`:**
- `run`: Czeka na caÅ‚Ä… odpowiedÅº, zwraca wynik po zakoÅ„czeniu
- `run_streamed`: WyÅ›wietla odpowiedÅº na bieÅ¼Ä…co, fragment po fragmencie (idealne dla UI)

---

## CzÄ™Å›Ä‡ 4: Programowanie asynchroniczne i rÃ³wnolegÅ‚e wywoÅ‚ania

### Wprowadzenie do asyncio

**Asyncio** to biblioteka Pythona do programowania asynchronicznego. Pozwala na wykonywanie wielu operacji jednoczeÅ›nie, co jest szczegÃ³lnie przydatne, gdy operacje czekajÄ… na odpowiedzi z sieci (np. wywoÅ‚ania API).

### Kluczowe koncepcje

#### 1. Funkcje asynchroniczne (async def)

Funkcja oznaczona jako `async def` moÅ¼e byÄ‡ wstrzymana (suspended) i wznowiona pÃ³Åºniej:

```python
async def moja_funkcja():
    # Ta funkcja moÅ¼e czekaÄ‡ na operacje I/O bez blokowania caÅ‚ego programu
    await jakas_operacja()
```

#### 2. Await

SÅ‚owo kluczowe `await` wstrzymuje wykonanie funkcji do czasu zakoÅ„czenia operacji:

```python
result = await Runner.run(agent, "WiadomoÅ›Ä‡")
# Kod poniÅ¼ej wykona siÄ™ dopiero po zakoÅ„czeniu Runner.run
```

#### 3. asyncio.gather

`asyncio.gather` pozwala uruchomiÄ‡ wiele operacji asynchronicznych rÃ³wnolegle:

```python
import asyncio

# Wszystkie trzy operacje uruchomiÄ… siÄ™ jednoczeÅ›nie
results = await asyncio.gather(
    Runner.run(agent1, message),
    Runner.run(agent2, message),
    Runner.run(agent3, message)
)
```

### Krok 4.1: RÃ³wnolegÅ‚e generowanie e-maili

Zamiast czekaÄ‡ na kaÅ¼dy e-mail osobno, moÅ¼emy wygenerowaÄ‡ wszystkie trzy jednoczeÅ›nie:

```python
import asyncio
from agents import Runner, trace

async def generate_parallel_emails(agent1, agent2, agent3, message):
    """Generuje trzy rÃ³Å¼ne e-maile rÃ³wnolegle"""
    with trace("RÃ³wnolegÅ‚e e-maile sprzedaÅ¼owe"):
        results = await asyncio.gather(
            Runner.run(agent1, message),
            Runner.run(agent2, message),
            Runner.run(agent3, message),
        )
    
    outputs = [result.final_output for result in results]
    return outputs

# UÅ¼ycie
message = "Napisz zimny e-mail sprzedaÅ¼owy"
emails = await generate_parallel_emails(sales_agent1, sales_agent2, sales_agent3, message)

for i, email in enumerate(emails, 1):
    print(f"\n--- E-mail {i} ---\n{email}\n")
```

**KorzyÅ›ci:**
- **OszczÄ™dnoÅ›Ä‡ czasu**: Zamiast 3 Ã— czas_pojedynczego_wywoÅ‚ania, otrzymujemy maksymalny czas z trzech wywoÅ‚aÅ„
- **Lepsze wykorzystanie zasobÃ³w**: Gdy jeden agent czeka na odpowiedÅº API, pÄ™tla zdarzeÅ„ przeÅ‚Ä…cza siÄ™ na innego

### Krok 4.2: WybÃ³r najlepszego e-maila

StwÃ³rzmy agenta, ktÃ³ry wybierze najlepszy e-mail z trzech wygenerowanych:

```python
from agents import Agent, Runner, trace

# Agent wybierajÄ…cy
sales_picker = Agent(
    name="WybÃ³r e-maila",
    instructions=(
        "Wybierasz najlepszy zimny e-mail sprzedaÅ¼owy z podanych opcji. "
        "WyobraÅº sobie, Å¼e jesteÅ› klientem i wybierz ten, na ktÃ³ry najprawdopodobniej odpowiesz. "
        "Nie podawaj wyjaÅ›nienia; odpowiedz tylko wybranym e-mailem."
    ),
    model="gpt-4o-mini",
)

async def select_best_email(agent1, agent2, agent3, picker_agent, message):
    """Generuje trzy warianty i wybiera najlepszy"""
    with trace("WybÃ³r z agentÃ³w sprzedaÅ¼y"):
        # Krok 1: Generowanie trzech wariantÃ³w rÃ³wnolegle
        results = await asyncio.gather(
            Runner.run(agent1, message),
            Runner.run(agent2, message),
            Runner.run(agent3, message),
        )
        outputs = [result.final_output for result in results]
        
        # Krok 2: Przygotowanie wiadomoÅ›ci dla agenta wybierajÄ…cego
        emails = "Zimne e-maile sprzedaÅ¼owe:\n\n" + "\n\nE-mail:\n\n".join(outputs)
        
        # Krok 3: WybÃ³r najlepszego e-maila
        best = await Runner.run(picker_agent, emails)
        
        return best.final_output

# UÅ¼ycie
best_email = await select_best_email(
    sales_agent1, sales_agent2, sales_agent3, sales_picker, 
    "Napisz zimny e-mail sprzedaÅ¼owy"
)
print(f"Najlepszy e-mail:\n{best_email}")
```

---

## CzÄ™Å›Ä‡ 5: NarzÄ™dzia (Tools) - Integracja funkcji z agentami

### Czym sÄ… narzÄ™dzia?

**NarzÄ™dzia (Tools)** to funkcje, ktÃ³re agenci mogÄ… wywoÅ‚ywaÄ‡ podczas swojej pracy. PozwalajÄ… one agentom na interakcjÄ™ ze Å›wiatem zewnÄ™trznym - wysyÅ‚anie e-maili, pobieranie danych, wykonywanie obliczeÅ„ itp.

### Problem: RÄ™czne tworzenie JSON Schema

W tradycyjnym podejÅ›ciu musielibyÅ›my rÄ™cznie tworzyÄ‡ JSON Schema dla kaÅ¼dej funkcji:

```python
# Tradycyjne podejÅ›cie (nie uÅ¼ywamy tego w OpenAI Agents SDK)
tool_schema = {
    "type": "function",
    "function": {
        "name": "send_email",
        "description": "WysyÅ‚a e-mail z podanÄ… treÅ›ciÄ…",
        "parameters": {
            "type": "object",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "TreÅ›Ä‡ wiadomoÅ›ci e-mail"
                }
            },
            "required": ["body"]
        }
    }
}
```

To jest Å¼mudne i podatne na bÅ‚Ä™dy!

### RozwiÄ…zanie: Dekorator @function_tool

OpenAI Agents SDK automatycznie generuje JSON Schema z metadanych Pythona:

```python
from agents import function_tool

@function_tool
def send_email(body: str) -> dict:
    """
    WysyÅ‚a e-mail z podanÄ… treÅ›ciÄ… do wszystkich potencjalnych klientÃ³w.
    
    Args:
        body: TreÅ›Ä‡ wiadomoÅ›ci e-mail do wysÅ‚ania
    
    Returns:
        SÅ‚ownik ze statusem operacji
    """
    # Implementacja funkcji
    return {"status": "success"}
```

**Co framework robi automatycznie:**
1. **Generuje nazwÄ™ narzÄ™dzia** z nazwy funkcji (`send_email`)
2. **Tworzy opis** z docstringa (komentarz w potrÃ³jnych cudzysÅ‚owach)
3. **Generuje JSON Schema** z type hints (`body: str` â†’ parametr typu string)

### Krok 5.1: Implementacja narzÄ™dzia do wysyÅ‚ki e-maili

```python
import os
import sendgrid
from agents import function_tool
from sendgrid.helpers.mail import Content, Email, Mail, To

@function_tool
def send_email(body: str) -> dict:
    """
    WysyÅ‚a e-mail z podanÄ… treÅ›ciÄ… do wszystkich potencjalnych klientÃ³w.
    """
    sg = sendgrid.SendGridAPIClient(api_key=os.environ.get("SENDGRID_API_KEY"))
    from_email = Email(os.environ.get("FROM_EMAIL"))
    to_email = To(os.environ.get("TO_EMAIL"))
    content = Content("text/plain", body)
    mail = Mail(from_email, to_email, "E-mail sprzedaÅ¼owy", content).get()
    sg.client.mail.send.post(request_body=mail)
    return {"status": "success"}
```

**Kluczowe elementy:**
- `@function_tool`: Dekorator konwertujÄ…cy funkcjÄ™ na narzÄ™dzie
- `body: str`: Type hint okreÅ›lajÄ…cy typ parametru
- Docstring: Opis funkcji uÅ¼ywany jako opis narzÄ™dzia dla LLM

### Krok 5.2: UÅ¼ycie narzÄ™dzia przez agenta

Aby agent mÃ³gÅ‚ uÅ¼ywaÄ‡ narzÄ™dzia, musimy przekazaÄ‡ je podczas tworzenia agenta:

```python
from agents import Agent, Runner, trace

# Tworzenie agenta z narzÄ™dziem
sales_manager = Agent(
    name="Kierownik SprzedaÅ¼y",
    instructions="""
    JesteÅ› Kierownikiem SprzedaÅ¼y w ComplAI. Twoim celem jest znalezienie najlepszego 
    zimnego e-maila sprzedaÅ¼owego uÅ¼ywajÄ…c narzÄ™dzi agentÃ³w sprzedaÅ¼y.
    
    PostÄ™puj zgodnie z tymi krokami:
    1. Generowanie wersji: UÅ¼yj wszystkich trzech narzÄ™dzi agentÃ³w sprzedaÅ¼y, 
       aby wygenerowaÄ‡ trzy rÃ³Å¼ne wersje e-maili. Nie przechodÅº dalej, 
       dopÃ³ki wszystkie trzy wersje nie bÄ™dÄ… gotowe.
    
    2. Ocena i wybÃ³r: Przejrzyj wersje i wybierz najlepszy e-mail uÅ¼ywajÄ…c 
       swojej oceny, ktÃ³ry jest najbardziej skuteczny.
    
    3. UÅ¼yj narzÄ™dzia send_email, aby wysÅ‚aÄ‡ najlepszy e-mail (i tylko najlepszy).
    
    Kluczowe zasady:
    - Musisz uÅ¼ywaÄ‡ narzÄ™dzi agentÃ³w sprzedaÅ¼y do generowania wersji â€” nie pisz ich sam.
    - Musisz wysÅ‚aÄ‡ JEDEN e-mail uÅ¼ywajÄ…c narzÄ™dzia send_email â€” nigdy wiÄ™cej niÅ¼ jeden.
    """,
    tools=[send_email],  # Przekazanie narzÄ™dzia
    model="gpt-4o-mini",
)

# Uruchomienie agenta
message = "WyÅ›lij zimny e-mail sprzedaÅ¼owy adresowany do 'Drogi CEO'"

with trace("Kierownik sprzedaÅ¼y"):
    result = await Runner.run(sales_manager, message)
```

**Co siÄ™ dzieje:**
1. Agent otrzymuje wiadomoÅ›Ä‡
2. Agent decyduje, Å¼e potrzebuje wygenerowaÄ‡ e-mail
3. Agent wywoÅ‚uje narzÄ™dzie `send_email` z wygenerowanÄ… treÅ›ciÄ…
4. Framework wykonuje funkcjÄ™ `send_email`
5. Agent otrzymuje wynik i kontynuuje pracÄ™

---

## CzÄ™Å›Ä‡ 6: Agent jako NarzÄ™dzie (Agent as a Tool)

### Koncepcja "Agent jako NarzÄ™dzie"

**Agent jako NarzÄ™dzie** to technika opakowywania agenta w narzÄ™dzie, ktÃ³re moÅ¼e byÄ‡ uÅ¼ywane przez innego agenta. Pozwala to na budowanie hierarchicznych systemÃ³w, gdzie "agent planista" (Manager) koordynuje pracÄ™ "agentÃ³w wykonawczych" (Sales Agents).

### RÃ³Å¼nica miÄ™dzy zwykÅ‚ym narzÄ™dziem a agentem jako narzÄ™dziem

| Typ | Opis | Kiedy uÅ¼ywaÄ‡ |
|-----|------|--------------|
| **ZwykÅ‚e narzÄ™dzie** | Funkcja Pythona z `@function_tool` | Proste operacje (wysyÅ‚ka e-maila, obliczenia) |
| **Agent jako narzÄ™dzie** | Agent opakowany w narzÄ™dzie | ZÅ‚oÅ¼one zadania wymagajÄ…ce rozumowania LLM |

### Krok 6.1: Konwersja agenta na narzÄ™dzie

```python
from agents import Agent

# Tworzenie agentÃ³w sprzedaÅ¼y
sales_agent1 = Agent(
    name="Profesjonalny Agent SprzedaÅ¼y",
    instructions=instructions_professional,
    model="gpt-4o-mini"
)

# Konwersja agenta na narzÄ™dzie
tool1 = sales_agent1.as_tool(
    tool_name="sales_agent1",
    tool_description="Napisz profesjonalny zimny e-mail sprzedaÅ¼owy"
)

# Teraz tool1 moÅ¼e byÄ‡ uÅ¼yte przez innego agenta!
```

**Co siÄ™ dzieje:**
1. Metoda `as_tool()` tworzy narzÄ™dzie z agenta
2. Gdy narzÄ™dzie jest wywoÅ‚ywane, framework faktycznie uruchamia agenta z jego instrukcjami
3. Wynik dziaÅ‚ania agenta jest zwracany jako wynik narzÄ™dzia

### Krok 6.2: Tworzenie hierarchii narzÄ™dzi

StwÃ³rzmy zestaw narzÄ™dzi skÅ‚adajÄ…cy siÄ™ z agentÃ³w i funkcji:

```python
def create_sales_agent_tools(agent1, agent2, agent3):
    """Konwertuje agentÃ³w sprzedaÅ¼y na narzÄ™dzia"""
    description = "Napisz zimny e-mail sprzedaÅ¼owy"
    
    tool1 = agent1.as_tool(tool_name="sales_agent1", tool_description=description)
    tool2 = agent2.as_tool(tool_name="sales_agent2", tool_description=description)
    tool3 = agent3.as_tool(tool_name="sales_agent3", tool_description=description)
    
    return [tool1, tool2, tool3]

# Tworzenie narzÄ™dzi
sales_tools = create_sales_agent_tools(sales_agent1, sales_agent2, sales_agent3)
sales_tools.append(send_email)  # Dodanie narzÄ™dzia do wysyÅ‚ki

# Teraz mamy 4 narzÄ™dzia: 3 agenty + 1 funkcja
```

### Krok 6.3: Agent kierownik z narzÄ™dziami

StwÃ³rzmy agenta kierownika, ktÃ³ry uÅ¼ywa wszystkich narzÄ™dzi:

```python
from agents import Agent, Runner, trace

def create_sales_manager_with_tools(sales_tools):
    """Tworzy agenta kierownika sprzedaÅ¼y z narzÄ™dziami"""
    instructions = """
    JesteÅ› Kierownikiem SprzedaÅ¼y w ComplAI. Twoim celem jest znalezienie 
    najlepszego zimnego e-maila sprzedaÅ¼owego uÅ¼ywajÄ…c narzÄ™dzi agentÃ³w sprzedaÅ¼y.
    
    PostÄ™puj zgodnie z tymi krokami:
    1. Generowanie wersji: UÅ¼yj wszystkich trzech narzÄ™dzi agentÃ³w sprzedaÅ¼y, 
       aby wygenerowaÄ‡ trzy rÃ³Å¼ne wersje e-maili. Nie przechodÅº dalej, 
       dopÃ³ki wszystkie trzy wersje nie bÄ™dÄ… gotowe.
    
    2. Ocena i wybÃ³r: Przejrzyj wersje i wybierz najlepszy e-mail uÅ¼ywajÄ…c 
       swojej oceny, ktÃ³ry jest najbardziej skuteczny.
    
    3. UÅ¼yj narzÄ™dzia send_email, aby wysÅ‚aÄ‡ najlepszy e-mail (i tylko najlepszy).
    
    Kluczowe zasady:
    - Musisz uÅ¼ywaÄ‡ narzÄ™dzi agentÃ³w sprzedaÅ¼y do generowania wersji â€” nie pisz ich sam.
    - Musisz wysÅ‚aÄ‡ JEDEN e-mail uÅ¼ywajÄ…c narzÄ™dzia send_email â€” nigdy wiÄ™cej niÅ¼ jeden.
    """
    
    return Agent(
        name="Kierownik SprzedaÅ¼y",
        instructions=instructions,
        tools=sales_tools,  # Wszystkie narzÄ™dzia
        model="gpt-4o-mini",
    )

# UÅ¼ycie
sales_manager = create_sales_manager_with_tools(sales_tools)

message = "WyÅ›lij zimny e-mail sprzedaÅ¼owy adresowany do 'Drogi CEO'"

with trace("Kierownik sprzedaÅ¼y"):
    result = await Runner.run(sales_manager, message)
```

**PrzepÅ‚yw dziaÅ‚ania:**
1. Agent kierownik otrzymuje wiadomoÅ›Ä‡
2. Agent kierownik wywoÅ‚uje `sales_agent1` (narzÄ™dzie) â†’ otrzymuje e-mail 1
3. Agent kierownik wywoÅ‚uje `sales_agent2` (narzÄ™dzie) â†’ otrzymuje e-mail 2
4. Agent kierownik wywoÅ‚uje `sales_agent3` (narzÄ™dzie) â†’ otrzymuje e-mail 3
5. Agent kierownik ocenia wszystkie trzy i wybiera najlepszy
6. Agent kierownik wywoÅ‚uje `send_email` (narzÄ™dzie) z najlepszym e-mailem

**Kluczowa rÃ³Å¼nica:** W tym przypadku to **LLM (agent kierownik) sam decyduje**, ktÃ³re narzÄ™dzie i kiedy wywoÅ‚aÄ‡. To przejÅ›cie od "przepÅ‚ywu pracy" (gdzie programista okreÅ›la kolejnoÅ›Ä‡) do "orkiestracji agentowej" (gdzie agent sam zarzÄ…dza procesem).

---

## CzÄ™Å›Ä‡ 7: Handoffs - Przekazywanie kontroli miÄ™dzy agentami

### Czym sÄ… Handoffs?

**Handoffs (Przekazania)** to mechanizm delegowania odpowiedzialnoÅ›ci, gdzie agent przekazuje caÅ‚e zadanie innemu, bardziej wyspecjalizowanemu agentowi. W przeciwieÅ„stwie do narzÄ™dzi, gdzie kontrola wraca do gÅ‚Ã³wnego agenta, w handoff kontrolÄ™ przejmuje drugi agent i koÅ„czy zadanie.

### PorÃ³wnanie: Tools vs Handoffs

| Cecha | NarzÄ™dzia (Tools) | Przekazania (Handoffs) |
|------|-------------------|------------------------|
| **PrzepÅ‚yw kontroli** | Dwukierunkowy: Agent â†’ NarzÄ™dzie â†’ Agent | Jednokierunkowy: Agent â†’ Agent (kontrola nie wraca) |
| **UÅ¼ycie** | MaÅ‚e, moduÅ‚owe kroki w wiÄ™kszym planie | Przekazanie zÅ‚oÅ¼onego, specjalistycznego zadania |
| **PrzykÅ‚ad** | "Wygeneruj wariant A", "Wygeneruj wariant B" | "PrzekazujÄ™ to do agenta mailujÄ…cego, ktÃ³ry zajmie siÄ™ resztÄ…" |

### Krok 7.1: Tworzenie agentÃ³w do formatowania e-maili

StwÃ³rzmy agentÃ³w odpowiedzialnych za formatowanie i wysyÅ‚kÄ™ e-maili:

```python
from agents import Agent, function_tool

# Agent do pisania tematÃ³w
subject_writer = Agent(
    name="Pisarz tematÃ³w e-maili",
    instructions=(
        "Potrafisz napisaÄ‡ temat dla zimnego e-maila sprzedaÅ¼owego. "
        "Otrzymujesz wiadomoÅ›Ä‡ i musisz napisaÄ‡ temat e-maila, ktÃ³ry prawdopodobnie otrzyma odpowiedÅº."
    ),
    model="gpt-4o-mini",
)

# Agent do konwersji na HTML
html_converter = Agent(
    name="Konwerter treÅ›ci e-maila na HTML",
    instructions=(
        "Potrafisz przekonwertowaÄ‡ treÅ›Ä‡ e-maila tekstowego na treÅ›Ä‡ HTML. "
        "Otrzymujesz treÅ›Ä‡ tekstowÄ…, ktÃ³ra moÅ¼e zawieraÄ‡ markdown, "
        "i musisz przekonwertowaÄ‡ jÄ… na treÅ›Ä‡ HTML z prostym, przejrzystym, przekonujÄ…cym ukÅ‚adem i designem."
    ),
    model="gpt-4o-mini",
)

# Konwersja agentÃ³w na narzÄ™dzia
subject_tool = subject_writer.as_tool(
    tool_name="subject_writer",
    tool_description="Napisz temat dla zimnego e-maila sprzedaÅ¼owego",
)

html_tool = html_converter.as_tool(
    tool_name="html_converter",
    tool_description="Przekonwertuj treÅ›Ä‡ e-maila tekstowego na treÅ›Ä‡ HTML",
)

# NarzÄ™dzie do wysyÅ‚ki HTML
@function_tool
def send_html_email(subject: str, html_body: str) -> dict:
    """WysyÅ‚a e-mail z podanym tematem i treÅ›ciÄ… HTML"""
    # Implementacja wysyÅ‚ki HTML (podobna do send_email)
    return {"status": "success"}
```

### Krok 7.2: Tworzenie agenta zarzÄ…dzajÄ…cego e-mailami

StwÃ³rzmy agenta, ktÃ³ry bÄ™dzie celem przekazania (handoff):

```python
from agents import Agent

def create_email_manager_agent():
    """Tworzy agenta zarzÄ…dzajÄ…cego formatowaniem i wysyÅ‚kÄ… e-maili"""
    # Lista narzÄ™dzi dla agenta zarzÄ…dzajÄ…cego
    tools = [subject_tool, html_tool, send_html_email]
    
    instructions = (
        "JesteÅ› formatowaczem i nadawcÄ… e-maili. Otrzymujesz treÅ›Ä‡ e-maila do wysÅ‚ania. "
        "Najpierw uÅ¼yj narzÄ™dzia subject_writer, aby napisaÄ‡ temat e-maila, "
        "nastÄ™pnie uÅ¼yj narzÄ™dzia html_converter, aby przekonwertowaÄ‡ treÅ›Ä‡ na HTML. "
        "Na koÅ„cu uÅ¼yj narzÄ™dzia send_html_email, aby wysÅ‚aÄ‡ e-mail z tematem i treÅ›ciÄ… HTML."
    )
    
    return Agent(
        name="MenedÅ¼er E-maili",
        instructions=instructions,
        tools=tools,
        model="gpt-4o-mini",
        handoff_description="Przekonwertuj e-mail na HTML i wyÅ›lij go",  # Kluczowe!
    )

email_manager = create_email_manager_agent()
```

**Kluczowy element:** `handoff_description` - opis, ktÃ³ry pozwala innemu agentowi zdecydowaÄ‡, Å¼e ten agent jest idealnym celem przekazania kontroli.

### Krok 7.3: Agent kierownik z handoff

Teraz stwÃ³rzmy agenta kierownika, ktÃ³ry uÅ¼ywa handoff:

```python
from agents import Agent, Runner, trace

def create_sales_manager_with_handoff(sales_tools, email_manager):
    """Tworzy agenta kierownika z moÅ¼liwoÅ›ciÄ… przekazania kontroli"""
    instructions = """
    JesteÅ› Kierownikiem SprzedaÅ¼y w ComplAI. Twoim celem jest znalezienie 
    najlepszego zimnego e-maila sprzedaÅ¼owego uÅ¼ywajÄ…c narzÄ™dzi agentÃ³w sprzedaÅ¼y.
    
    PostÄ™puj zgodnie z tymi krokami:
    1. Generowanie wersji: UÅ¼yj wszystkich trzech narzÄ™dzi agentÃ³w sprzedaÅ¼y, 
       aby wygenerowaÄ‡ trzy rÃ³Å¼ne wersje e-maili. Nie przechodÅº dalej, 
       dopÃ³ki wszystkie trzy wersje nie bÄ™dÄ… gotowe.
    
    2. Ocena i wybÃ³r: Przejrzyj wersje i wybierz najlepszy e-mail uÅ¼ywajÄ…c 
       swojej oceny, ktÃ³ry jest najbardziej skuteczny. MoÅ¼esz uÅ¼ywaÄ‡ narzÄ™dzi 
       wielokrotnie, jeÅ›li nie jesteÅ› zadowolony z wynikÃ³w z pierwszego podejÅ›cia.
    
    3. Przekazanie do wysyÅ‚ki: PrzekaÅ¼ TYLKO zwyciÄ™skÄ… wersjÄ™ e-maila agentowi 
       'MenedÅ¼er E-maili'. MenedÅ¼er E-maili zajmie siÄ™ formatowaniem i wysyÅ‚kÄ….
    
    Kluczowe zasady:
    - Musisz uÅ¼ywaÄ‡ narzÄ™dzi agentÃ³w sprzedaÅ¼y do generowania wersji â€” nie pisz ich sam.
    - Musisz przekazaÄ‡ dokÅ‚adnie JEDEN e-mail MenedÅ¼erowi E-maili â€” nigdy wiÄ™cej niÅ¼ jeden.
    """
    
    return Agent(
        name="Kierownik SprzedaÅ¼y",
        instructions=instructions,
        tools=sales_tools,  # NarzÄ™dzia do generowania
        handoffs=[email_manager],  # Przekazanie do formatowania i wysyÅ‚ki
        model="gpt-4o-mini",
    )

# UÅ¼ycie
sales_manager = create_sales_manager_with_handoff(sales_tools, email_manager)

message = "WyÅ›lij zimny e-mail sprzedaÅ¼owy adresowany do Drogi CEO od Alicji"

with trace("Zautomatyzowany SDR"):
    result = await Runner.run(sales_manager, message)
```

**PrzepÅ‚yw dziaÅ‚ania z handoff:**
1. Agent kierownik generuje 3 e-maile (uÅ¼ywajÄ…c Tools) â†’ kontrola wraca
2. Agent kierownik wybiera najlepszy
3. Agent kierownik **przekazuje kontrolÄ™** (Handoff) agentowi MenedÅ¼er E-maili
4. **Kontrola NIE WRACA** do kierownika
5. MenedÅ¼er E-maili uÅ¼ywa swoich narzÄ™dzi: Temat â†’ Konwersja HTML â†’ WysyÅ‚ka

**RÃ³Å¼nica w Å›ledzeniu (trace):**
- **NarzÄ™dzia**: Na poczÄ…tku Å›ladu kierownik wywoÅ‚uje agentÃ³w sprzedaÅ¼y, kontrola wraca
- **Przekazanie**: Pod koniec Å›ladu kierownik przekazuje kontrolÄ™, caÅ‚a pÃ³Åºniejsza aktywnoÅ›Ä‡ jest realizowana przez MenedÅ¼era E-maili

---

## CzÄ™Å›Ä‡ 8: Wzorce projektowe agentÃ³w

### Wzorzec 1: Wariacje + WybÃ³r

W tym wzorcu generujemy wiele wariantÃ³w, a nastÄ™pnie wybieramy najlepszy:

```python
# Generowanie wariantÃ³w
variants = await asyncio.gather(
    generate_variant_1(),
    generate_variant_2(),
    generate_variant_3(),
)

# WybÃ³r najlepszego
best = await select_best(variants)
```

**Zastosowanie:** Generowanie treÅ›ci, optymalizacja, A/B testing

### Wzorzec 2: Hierarchiczna delegacja

W tym wzorcu agent planista deleguje zadania do agentÃ³w wykonawczych:

```python
# Agent planista
manager = Agent(
    tools=[agent1_tool, agent2_tool, agent3_tool],
    handoffs=[specialist_agent]
)

# Agent specjalista
specialist = Agent(
    tools=[specialized_tools],
    handoff_description="Specjalistyczne zadanie"
)
```

**Zastosowanie:** ZÅ‚oÅ¼one procesy biznesowe, automatyzacja workflow

### Wzorzec 3: Pipeline z handoff

W tym wzorcu zadanie przechodzi przez sekwencjÄ™ agentÃ³w:

```python
# Agent A â†’ Agent B â†’ Agent C
agent_a = Agent(handoffs=[agent_b])
agent_b = Agent(handoffs=[agent_c])
agent_c = Agent(tools=[final_tools])
```

**Zastosowanie:** Przetwarzanie dokumentÃ³w, analiza danych, raportowanie

---

## CzÄ™Å›Ä‡ 9: Åšledzenie i debugowanie

### Platforma OpenAI Traces

Wszystkie operacje wewnÄ…trz bloku `with trace(...)` sÄ… automatycznie logowane na platformie OpenAI:

```python
with trace("Nazwa operacji"):
    result = await Runner.run(agent, message)
```

**Jak sprawdziÄ‡ Å›lady:**
1. OdwiedÅº [https://platform.openai.com/traces](https://platform.openai.com/traces)
2. Zaloguj siÄ™ na swoje konto OpenAI
3. Zobacz szczegÃ³Å‚owe Å›lady wszystkich operacji agentÃ³w

**Co moÅ¼esz zobaczyÄ‡:**
- KtÃ³re narzÄ™dzia zostaÅ‚y wywoÅ‚ane
- Jakie byÅ‚y odpowiedzi agentÃ³w
- PrzepÅ‚yw kontroli miÄ™dzy agentami
- Czas wykonania kaÅ¼dej operacji

### Debugowanie problemÃ³w

#### Problem: Agent nie wywoÅ‚uje narzÄ™dzia

**RozwiÄ…zanie:**
- SprawdÅº, czy narzÄ™dzie jest dodane do listy `tools`
- Upewnij siÄ™, Å¼e opis narzÄ™dzia (docstring) jest jasny
- SprawdÅº instrukcje agenta - czy sÄ… wystarczajÄ…co precyzyjne?

#### Problem: BÅ‚Ä™dy SSL przy wysyÅ‚ce e-maili

**RozwiÄ…zanie:**
```bash
pip install --upgrade certifi
```

```python
import certifi
import os
os.environ['SSL_CERT_FILE'] = certifi.where()
```

#### Problem: E-maile nie docierajÄ…

**SprawdÅº:**
1. Folder spam w skrzynce odbiorczej
2. Status odpowiedzi SendGrid (powinien byÄ‡ 202)
3. WeryfikacjÄ™ nadawcy w SendGrid
4. Logi w SendGrid Dashboard

---

## CzÄ™Å›Ä‡ 10: Zaawansowane techniki

### Dynamiczne tworzenie agentÃ³w

MoÅ¼esz tworzyÄ‡ agentÃ³w dynamicznie na podstawie danych:

```python
def create_agent_for_industry(industry: str) -> Agent:
    """Tworzy agenta specjalizujÄ…cego siÄ™ w danej branÅ¼y"""
    instructions = f"""
    JesteÅ› agentem sprzedaÅ¼y specjalizujÄ…cym siÄ™ w branÅ¼y {industry}.
    Piszesz e-maile sprzedaÅ¼owe dostosowane do specyfiki tej branÅ¼y.
    """
    return Agent(
        name=f"Agent dla {industry}",
        instructions=instructions,
        model="gpt-4o-mini"
    )

# UÅ¼ycie
tech_agent = create_agent_for_industry("technologia")
finance_agent = create_agent_for_industry("finanse")
```

### Warunkowe przekazania

MoÅ¼esz uÅ¼ywaÄ‡ logiki warunkowej do decydowania o przekazaniach:

```python
def create_smart_router() -> Agent:
    """Agent routujÄ…cy, ktÃ³ry decyduje, do ktÃ³rego specjalisty przekazaÄ‡ zadanie"""
    return Agent(
        name="Router",
        instructions="""
        Analizujesz zapytanie i decydujesz, do ktÃ³rego specjalisty je przekazaÄ‡:
        - JeÅ›li dotyczy technologii â†’ przekaÅ¼ do Tech Specialist
        - JeÅ›li dotyczy finansÃ³w â†’ przekaÅ¼ do Finance Specialist
        - W przeciwnym razie â†’ obsÅ‚uÅ¼ sam
        """,
        handoffs=[tech_specialist, finance_specialist],
        model="gpt-4o-mini"
    )
```

### RÃ³wnolegÅ‚e przekazania

MoÅ¼esz przekazaÄ‡ zadanie do wielu agentÃ³w jednoczeÅ›nie:

```python
# Agent, ktÃ³ry moÅ¼e przekazaÄ‡ do wielu specjalistÃ³w
coordinator = Agent(
    name="Koordynator",
    instructions="Przekazuj zadania do odpowiednich specjalistÃ³w",
    handoffs=[specialist1, specialist2, specialist3],
    model="gpt-4o-mini"
)
```

---

## CzÄ™Å›Ä‡ 11: Najlepsze praktyki

### 1. Pisanie dobrych instrukcji

**Dobre instrukcje:**
- âœ… SÄ… konkretne i precyzyjne
- âœ… ZawierajÄ… przykÅ‚ady, gdy to moÅ¼liwe
- âœ… OkreÅ›lajÄ… jasne kroki do wykonania
- âœ… ZawierajÄ… kluczowe zasady i ograniczenia

**ZÅ‚e instrukcje:**
- âŒ SÄ… zbyt ogÃ³lne ("BÄ…dÅº pomocny")
- âŒ SÄ… niejasne ("ZrÃ³b to dobrze")
- âŒ Brakuje kontekstu

### 2. Projektowanie narzÄ™dzi

**Dobre narzÄ™dzie:**
- âœ… Ma jasny, opisowy docstring
- âœ… UÅ¼ywa type hints dla parametrÃ³w
- âœ… Zwraca strukturyzowane dane (dict, list)
- âœ… ObsÅ‚uguje bÅ‚Ä™dy gracefully

**PrzykÅ‚ad:**
```python
@function_tool
def get_weather(city: str) -> dict:
    """
    Pobiera aktualnÄ… pogodÄ™ dla podanego miasta.
    
    Args:
        city: Nazwa miasta (np. "Warszawa", "KrakÃ³w")
    
    Returns:
        SÅ‚ownik z danymi pogodowymi: {"temperature": 20, "condition": "sunny"}
    """
    # Implementacja
    return {"temperature": 20, "condition": "sunny"}
```

### 3. ZarzÄ…dzanie kosztami

**Optymalizacja kosztÃ³w:**
- UÅ¼ywaj `gpt-4o-mini` dla prostych zadaÅ„
- UÅ¼ywaj `gpt-4o` tylko dla zÅ‚oÅ¼onych zadaÅ„ wymagajÄ…cych gÅ‚Ä™bszego rozumowania
- Ograniczaj dÅ‚ugoÅ›Ä‡ instrukcji (ale nie kosztem jakoÅ›ci)
- UÅ¼ywaj rÃ³wnolegÅ‚ych wywoÅ‚aÅ„, aby skrÃ³ciÄ‡ czas wykonania

### 4. ObsÅ‚uga bÅ‚Ä™dÃ³w

Zawsze obsÅ‚uguj bÅ‚Ä™dy w narzÄ™dziach:

```python
@function_tool
def safe_api_call(param: str) -> dict:
    """Bezpieczne wywoÅ‚anie API z obsÅ‚ugÄ… bÅ‚Ä™dÃ³w"""
    try:
        result = external_api.call(param)
        return {"status": "success", "data": result}
    except Exception as e:
        return {"status": "error", "message": str(e)}
```

---

## CzÄ™Å›Ä‡ 12: PrzykÅ‚ady zastosowaÅ„

### PrzykÅ‚ad 1: Automatyzacja obsÅ‚ugi klienta

```python
# Agent triage - klasyfikuje zapytania
triage_agent = Agent(
    name="Triage",
    instructions="Klasyfikujesz zapytania klientÃ³w do odpowiednich kategorii",
    handoffs=[support_agent, sales_agent, technical_agent],
    model="gpt-4o-mini"
)

# SpecjaliÅ›ci
support_agent = Agent(
    name="Wsparcie",
    tools=[knowledge_base_tool, ticket_system_tool],
    model="gpt-4o-mini"
)
```

### PrzykÅ‚ad 2: Automatyzacja rekrutacji

```python
# Pipeline rekrutacyjny
sourcing_agent = Agent(
    name="Sourcing",
    tools=[linkedin_tool, job_boards_tool],
    handoffs=[cv_reviewer],
    model="gpt-4o-mini"
)

cv_reviewer = Agent(
    name="Recenzent CV",
    tools=[cv_parser_tool, skills_matcher_tool],
    handoffs=[interview_scheduler],
    model="gpt-4o-mini"
)

interview_scheduler = Agent(
    name="Planista wywiadÃ³w",
    tools=[calendar_tool, email_tool],
    model="gpt-4o-mini"
)
```

### PrzykÅ‚ad 3: Analiza i raportowanie

```python
# System analityczny
data_collector = Agent(
    name="Zbieracz danych",
    tools=[database_tool, api_tool],
    handoffs=[data_analyzer],
    model="gpt-4o-mini"
)

data_analyzer = Agent(
    name="Analityk",
    tools=[statistics_tool, visualization_tool],
    handoffs=[report_generator],
    model="gpt-4o-mini"
)

report_generator = Agent(
    name="Generator raportÃ³w",
    tools=[template_tool, pdf_generator_tool],
    model="gpt-4o-mini"
)
```

---

## Podsumowanie

### Kluczowe koncepcje

1. **Agent**: Inteligentny asystent z okreÅ›lonymi instrukcjami
2. **NarzÄ™dzia (Tools)**: Funkcje, ktÃ³re agenci mogÄ… wywoÅ‚ywaÄ‡
3. **Agent jako NarzÄ™dzie**: Opakowanie agenta w narzÄ™dzie dla innego agenta
4. **Przekazania (Handoffs)**: Delegowanie caÅ‚ego zadania innemu agentowi
5. **AsynchronicznoÅ›Ä‡**: RÃ³wnolegÅ‚e wykonywanie operacji dla lepszej wydajnoÅ›ci

### RÃ³Å¼nica miÄ™dzy przepÅ‚ywem pracy a orkiestracjÄ… agentowÄ…

| PrzepÅ‚yw pracy | Orkiestracja agentowa |
|----------------|----------------------|
| Programista okreÅ›la kolejnoÅ›Ä‡ | Agent sam decyduje o kolejnoÅ›ci |
| `agent1 â†’ agent2 â†’ agent3` | Agent wybiera, ktÃ³re narzÄ™dzie uÅ¼yÄ‡ |
| Statyczny, przewidywalny | Dynamiczny, adaptacyjny |

**PrzejÅ›cie nastÄ™puje, gdy:**
- Dodajemy narzÄ™dzia do agenta
- Dajemy agentowi instrukcje, aby sam decydowaÅ‚ o uÅ¼yciu narzÄ™dzi
- Agent otrzymuje autonomiÄ™ decyzyjnÄ…

### NastÄ™pne kroki

1. **Eksperymentuj**: SprÃ³buj rÃ³Å¼nych instrukcji i konfiguracji
2. **Rozszerzaj**: Dodaj wiÄ™cej narzÄ™dzi i agentÃ³w
3. **Integruj**: PoÅ‚Ä…cz z innymi systemami (CRM, bazy danych, API)
4. **Monitoruj**: UÅ¼ywaj Å›ledzenia do optymalizacji
5. **Ucz siÄ™**: Analizuj Å›lady, aby zrozumieÄ‡, jak agenci podejmujÄ… decyzje

### Przydatne linki

- [Dokumentacja OpenAI Agents SDK](https://github.com/openai/openai-agents-python)
- [Platforma OpenAI Traces](https://platform.openai.com/traces)
- [SendGrid Documentation](https://docs.sendgrid.com/)
- [Python asyncio Documentation](https://docs.python.org/3/library/asyncio.html)

---

## FAQ

### P: Czy mogÄ™ uÅ¼ywaÄ‡ innych modeli niÅ¼ GPT-4o-mini?

**O:** Tak! MoÅ¼esz uÅ¼ywaÄ‡ dowolnego modelu obsÅ‚ugiwanego przez OpenAI API, np. `gpt-4o`, `gpt-4-turbo`. PamiÄ™taj jednak o rÃ³Å¼nicach w kosztach i wydajnoÅ›ci.

### P: Jak obsÅ‚uÅ¼yÄ‡ bÅ‚Ä™dy w narzÄ™dziach?

**O:** Zawsze uÅ¼ywaj try-except w narzÄ™dziach i zwracaj strukturyzowane odpowiedzi z informacjÄ… o bÅ‚Ä™dzie. Agent moÅ¼e nastÄ™pnie zdecydowaÄ‡, jak zareagowaÄ‡ na bÅ‚Ä…d.

### P: Czy mogÄ™ mieÄ‡ zagnieÅ¼dÅ¼one handoffs?

**O:** Tak! Agent A moÅ¼e przekazaÄ‡ kontrolÄ™ agentowi B, ktÃ³ry z kolei moÅ¼e przekazaÄ‡ kontrolÄ™ agentowi C. To umoÅ¼liwia budowanie zÅ‚oÅ¼onych pipeline'Ã³w.

### P: Jak ograniczyÄ‡ koszty?

**O:** 
- UÅ¼ywaj `gpt-4o-mini` dla prostych zadaÅ„
- Ograniczaj dÅ‚ugoÅ›Ä‡ instrukcji
- UÅ¼ywaj rÃ³wnolegÅ‚ych wywoÅ‚aÅ„, aby skrÃ³ciÄ‡ czas
- Monitoruj uÅ¼ycie przez Å›ledzenie

### P: Czy mogÄ™ uÅ¼ywaÄ‡ lokalnych modeli LLM?

**O:** OpenAI Agents SDK jest zaprojektowany dla modeli OpenAI. Dla lokalnych modeli moÅ¼esz potrzebowaÄ‡ innego frameworka lub wÅ‚asnej implementacji.

---

**Gratulacje!** UkoÅ„czyÅ‚eÅ› kompleksowy kurs budowy systemu wieloagentowego z OpenAI Agents SDK. Masz teraz wiedzÄ™ i narzÄ™dzia, aby tworzyÄ‡ zaawansowane aplikacje wykorzystujÄ…ce AI.

Powodzenia w budowaniu wÅ‚asnych systemÃ³w agentowych! ğŸš€

